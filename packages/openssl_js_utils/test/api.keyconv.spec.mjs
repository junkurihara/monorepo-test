import jscu from '../src/index.mjs';

let crypto;
if (typeof window !== 'undefined' && typeof window.crypto !== 'undefined' && typeof window.crypto.subtle === 'object'
  && typeof window.crypto.subtle.importKey === 'function' && typeof window.crypto.subtle.sign === 'function') {
  crypto = window.crypto;
}
else crypto = null;

import chai from 'chai';
// const should = chai.should();
const expect = chai.expect;

const curves = ['P-256', 'P-384', 'P-521'];
const hashes = [ 'SHA-256', 'SHA-384', 'SHA-512'];
describe('Generated JWK key should be successfully converted to PEM SPKI/PKCS8, and vice varsa', () => {
  const getKeyParam = (elem) => {
    const keyParams =  {
      extractable: true,
      keyUsage: ['sign', 'verify']
    };
    const algo = {algo: {name: 'ECDSA', namedCurve: elem}};
    return Object.assign(algo, keyParams);
  };
  let keySet = [];
  let msg;
  before( async () => {
    if (!crypto){
      crypto = await import('node-webcrypto-ossl');
      if(typeof crypto !== 'undefined' && typeof crypto.WebCrypto !== 'function' && typeof crypto.default !=='undefined')
        crypto = crypto.default;
      crypto = new crypto();
    }

    keySet = await Promise.all(curves.map( async (crv) => {
      const param = getKeyParam(crv);
      return await jscu.crypto.generateKeyPair(param);
    }));
    msg = new Uint8Array(32);
    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;
  });


  it('Signature generated by JWK should be successfully verified by converted PEM (bin) key via WebCrypto.', async () => {
    await Promise.all(
      curves.map( async (curve, idx) => await Promise.all(
        hashes.map( async (hash) => {
          const sig = await jscu.crypto.sign(msg, keySet[idx].privateKey.key, {name: 'ECDSA', namedCurve: curve, hash: { name: hash }});

          const pemPub = await jscu.crypto.keyconv.jwkToPem(keySet[idx].publicKey.key, 'public');
          const binKey = await jscu.helper.formatter.pemToBin(pemPub);
          const key = await crypto.subtle.importKey('spki', binKey, {name: 'ECDSA', namedCurve: curve}, true, ['verify']);
          const result = await crypto.subtle.verify({name: 'ECDSA', namedCurve: curve, hash: { name: hash }}, key, sig, msg);
          expect(result).to.be.true;
          return result;
        })
      ))
    );
  });

  it('Signature generated by WebCrypto with convereted PEM (bin) key should be successfully verified by JWK', async () => {
    await Promise.all(
      curves.map( async (curve, idx) => await Promise.all(
        hashes.map( async (hash) => {
          const pemPriv = await jscu.crypto.keyconv.jwkToPem(keySet[idx].privateKey.key, 'private');
          const binKey = await jscu.helper.formatter.pemToBin(pemPriv);
          const key = await crypto.subtle.importKey('pkcs8', binKey, {name: 'ECDSA', namedCurve: curve}, false, ['sign']);
          const sig = await crypto.subtle.sign({name: 'ECDSA', namedCurve: curve, hash: { name: hash }}, key, msg);
          const result = await jscu.crypto.verify(msg, sig, keySet[idx].publicKey.key, {name: 'ECDSA', namedCurve: curve, hash: { name: hash }});
          expect(result).to.be.true;
          return result;
        })
      ))
    );
  });
});

describe('PEM SPKI/PKCS8 key should be successfully converted to usable JWK', () => {
  const pubOSSL =
    '-----BEGIN PUBLIC KEY-----\n' +
    'MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEpbsQYkkaJa+rvxkad9m7gOuc8p3D\n' +
    'qd8N37+bvD59VPVPgkbVHFjzeJqZMk5TS4/RbT8SUqKmQ2sb1l+svNP8LQ==\n' +
    '-----END PUBLIC KEY-----';
  const privOSSL =
    '-----BEGIN PRIVATE KEY-----\n' +
    'MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg8N6DZSFlKf+X6MaN\n' +
    'qo3hc7J2q4HeWn+E71cKfPhRtqOhRANCAASluxBiSRolr6u/GRp32buA65zyncOp\n' +
    '3w3fv5u8Pn1U9U+CRtUcWPN4mpkyTlNLj9FtPxJSoqZDaxvWX6y80/wt\n' +
    '-----END PRIVATE KEY-----\n';
  let msg;
  before( async () => {
    msg = new Uint8Array(32);
    for(let i = 0; i < 32; i++) msg[i] = 0xFF & i;
  });

  it('JWK converted from PEM should successfully sign and verify messages', async () => {
    await Promise.all(
      hashes.map( async (hash) => {
        const jwkPriv = await jscu.crypto.keyconv.pemToJwk(privOSSL, 'private', {name: 'ECDSA'});
        const jwkPub = await jscu.crypto.keyconv.pemToJwk(pubOSSL, 'public', {name: 'ECDSA'});

        const sig = await jscu.crypto.sign(msg, jwkPriv, {name: 'ECDSA', namedCurve: jwkPriv.crv, hash: { name: hash }});
        const result = await jscu.crypto.verify(msg, sig, jwkPub, {name: 'ECDSA', namedCurve: jwkPub.crv, hash: { name: hash }});
        expect(result).to.be.true;
        return result;
      })
    );
  });
});